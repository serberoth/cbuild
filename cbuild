#!/usr/bin/env ruby

require 'fileutils'
require 'find'
require 'json'

class String
    %w{black red green yellow blue magenta cyan white}.each_with_index do |colour, index|
        define_method "#{colour}" do
            return "\e[3#{index}m#{self}\e[0m"
        end
        define_method "#{colour}_bkg" do
            return "\e[4#{index}m#{self}\e[0m"
        end
    end

    # %w{bold italic underline blink reverse_colour}.each_with_index, do |special, index|
    #     define_method "#{special}" do
    #         return "\e[#{index}m#{self}\e[2#{index}m"
    #     end
    # end

    def bold;           "\e[1m#{self}\e[22m" end
    def italic;         "\e[3m#{self}\e[23m" end
    def underline;      "\e[4m#{self}\e[24m" end
    def blink;          "\e[5m#{self}\e[25m" end
    def reverse_colour; "\e[7m#{self}\e[27m" end

end

class Flags
    attr_accessor :build_flag
    attr_accessor :test_flag
    attr_accessor :clean_flag
    attr_accessor :tasks_flag
    attr_accessor :default_flag
    attr_accessor :verbose_flag
    attr_accessor :properties_file
    attr_accessor :build_mode
    attr_accessor :test_list

    def initialize(arguments)
        self.build_flag = false
        self.test_flag = false
        self.clean_flag = false
        self.tasks_flag = false
        self.default_flag = true
        self.verbose_flag = false
        self.properties_file = 'build.json'
        self.build_mode = 'release'
        self.test_list = []

        arguments.each do |item|
            case item
            when 'clean'
                self.clean_flag = true
                self.default_flag = false
            when 'build'
                self.build_flag = true
                self.default_flag = false
            when /build:(.*)/
                self.build_flag = true
                self.build_mode = $1
                self.default_flag = false
            when 'test'
                self.test_flag = true
                self.default_flag = false
            when /test\[([^\]]*)\]/
                self.test_flag = true
                self.default_flag = false
                self.test_list = $1.split(',').each{|s| s.strip!}.keep_if{|s| !s.nil? && !s.empty? }
            when 'tasks'
                self.tasks_flag = true
            when /-f=(.*)/
                self.properties_file = $1
            when '-verbose'
                self.verbose_flag = true
            when '-v'
                self.verbose_flag = true
            else
                puts "#{'ERROR'.red}: Invalid parameter option #{item.white.bold}"
                self.tasks_flag = true
            end
        end
    end

    def print_tasks
        puts 'Build System Tasks:'
        puts 'clean - Clean the build directory'
        puts 'build - Build the target executable'
        puts 'build:<mode> - Build the specified target mode'
        puts 'test - Execute the project unit test suites'
        puts 'test[<test>(,<test>...)] - Execute the project unit test suites for the specified suites'
        puts 'tasks - Print the build tasks list'
        puts '-f=<filename> - Use <filename> for the build project properties'
        puts '-verbose - Enable verbose output'
        exit! 0
    end
        
end

class Builder
    attr_accessor :target, :output, :mode
    attr_accessor :source_dirs, :source_filters
    attr_accessor :test_dir, :test_list
    attr_accessor :compiler, :compiler_options, :compiler_mode_options
    attr_accessor :linker, :linker_options, :linker_mode_options
    attr_accessor :language
    attr_accessor :prebuild, :postbuild

    def initialize(flags)
        if !File.exists? flags.properties_file
            puts "#{'ERROR'.red}: Project JSON #{flags.properties_file.white.bold} does not exists in the current directory."
            puts "Please make sure you are in the correct project directory and are specifying the correct project file."
            exit -1
        end

        begin
            @properties = JSON.parse(File.read(flags.properties_file))
        rescue JSON::JSONError => e
            puts "#{'ERROR'.red}: Unable to correctly parse project JSON configuration file: #{flags.properties_file.white.bold}"
            puts "#{'ERROR'.red}: #{e.message}"
            exit -1
        end
        @flags = flags

        self.target = @properties['target'] || 'output'
        self.output = @properties['output'] || './build'
        self.mode = flags.build_mode
        if flags.test_flag
            self.mode = 'debug'
        elsif self.mode == 'global'
            self.mode = 'release'
        end

        self.compiler = @properties['cc'] || 'cc'
        self.linker = @properties['ld'] || 'ld'
        self.language = @properties['language'] || 'c17'

        self.source_dirs = @properties['sources'] || [ './' ]
        self.source_filters = @properties['filters'] || []

        self.test_dir = @properties['tests'] || './test'
        self.test_list = flags.test_list || []
        
        self.compiler_options = []
        self.compiler_mode_options = []
        if !@properties['compiler.options'].nil?
            if @properties['compiler.options'].class == Array
                self.compiler_options = @properties['compiler.options'] || []
                self.compiler_mode_options = @properties["compiler.#{mode}.options"] || []
            elsif @properties['compiler.options'].class == Hash
                self.compiler_options = @properties['compiler.options']['global'] || []
                self.compiler_mode_options = @properties['compiler.options'][mode] || []
            end
        end
        
        self.linker_options = []
        self.linker_mode_options = []
        if !@properties['linker.options'].nil?
            if @properties['linker.options'].class == Array
                self.linker_options = @properties['linker.options'] || []
                self.linker_mode_options = @properties["linker.#{mode}.options"] || []
            elsif @properties['linker.options'].class == Hash
                self.linker_options = @properties['linker.options']['global'] || []
                self.linker_mode_options = @properties['linker.options'][mode] || []
            end
        end

        self.prebuild = @properties['prebuild'] || []
        self.postbuild = @properties['postbuild'] || []
    end

    def clean
        puts 'Cleaning build directory'
        FileUtils.rm_r self.output if File.exists? self.output
        puts "#{'SUCCESS'.green} - Project build directory cleaned"
    end

    def test
        puts 'Building and executing test suite'
        result = assemble_run_tests

        puts "#{'SUCCESS'.green} - Unit tests completed successfully" if result
    end

    def build
        exec_prebuild
        result = assemble
        exec_postbuild

        puts "#{'SUCCESS'.green} - Build completed successfully" if File.exists? "#{self.output}/exec/#{self.target}" if result
    end

private
    def exec_prebuild
        build_commands self.prebuild, 'Prebuild'
    end

    def exec_postbuild
        build_commands self.postbuild, 'Postbuild'
    end

    def assemble_objects verbose
        FileUtils.mkdir_p "#{self.output}/objs"

        include_dirs = self.source_dirs.map {|dir| "-I#{dir}" }.join ' '
        puts "Include Directories: #{include_dirs}".cyan if verbose

        source_list = []
        object_list = []
        self.source_dirs.each do |dir|
            Find.find(dir) do |path|
                next if filter? path

                extension = File.extname(path)
                basename = File.basename(path, extension)

                object = "#{self.output}/objs/#{basename}.o"
                options = [ self.compiler_options.join(' '), self.compiler_mode_options.join(' ') ].join(' ')
                puts "#{'Compiling'.blue}: #{path.white.bold} -> #{object.white.bold}"
                command = "#{self.compiler} -c -o #{object} #{path} -std=#{self.language} #{options} -D#{self.mode.upcase} #{include_dirs}"
                puts command.cyan if verbose
                puts %x{ #{command} }
                source_list.append path
                object_list.append object if $?.exited? && ($?.exitstatus == 0)
            end
        end
        return source_list, object_list
    end

    def assemble_run_tests
        puts "Assembling tests"
        verbose = @flags.verbose_flag
        FileUtils.mkdir_p "#{self.output}/tests/objs"
        FileUtils.mkdir_p "#{self.output}/tests/exec"

        source_list, object_list = assemble_objects(verbose)

        unless (object_list.length > 0) && (object_list.length == source_list.length)
            puts "#{'FAILED'.red} - See compilation output for details"
            return false
        end

        if (object_list.length > 0) && (object_list.length == source_list.length)
            # Remove the object with the application main from the available objects in the test suite
            # This does make any sumbols contained within that untestable
            object_list.delete_if {|obj|
                dump = %x{ objdump -t #{obj} | grep _main$ }
                puts "Main Object: #{obj.white.bold} => #{dump}" if verbose && (dump != '')
                dump != ''
            }

            include_dirs = self.source_dirs.map {|dir| "-I#{dir}" }.join ' '
            include_dirs += " -I#{self.test_dir}"
            puts "Include Directories: #{include_dirs}".cyan if verbose

            commands = []
            count = 0
            Find.find(self.test_dir) do |path|
                next if filter? path
                # skip tests that are not specified in the list
                puts "#{self.test_dir} #{path} :: !#{test_list}.include?(#{path[(self.test_dir.length+1)...-2]}) == #{!self.test_list.include?(path[self.test_dir.length, -2])}" if verbose && !self.test_list.empty?
                next if !self.test_list.empty? && !self.test_list.include?(path[(self.test_dir.length+1)...-2])

                count += 1
                cmd = assemble_test(path, include_dirs, object_list, verbose)
                commands.append([path, cmd]) unless cmd.nil?
            end

            results = []
            commands.each{|path, cmd| results.append(run_test path, cmd, verbose) }
            puts ''
            puts "Executed #{count} suites #{count - commands.count} errors #{results.count(false)} failures".white.bold
            result = results.count(false) == 0 && (count - commands.count) == 0
            puts "#{'FAILED'.red} - Test suites failed; see output for details" unless result
            return result
        end
    end

    def assemble_test test, include_dirs, object_list, verbose
        puts "#{'Assembling Test'.cyan}: #{test.white.bold}"

        extension = File.extname(test)
        basename = File.basename(test, extension)

        object = "#{self.output}/tests/objs/#{basename}.o"
        target = "#{self.output}/tests/exec/#{basename}"

        File.delete target if File.exists? target

        options = [ self.compiler_options.join(' '), self.compiler_mode_options.join(' ') ].join(' ')
        puts "#{'Compiling'.blue}: #{test.white.bold} -> #{object.white.bold}"
        command = "#{self.compiler} -c -o #{object} #{test} -std=#{self.language} #{options} -D#{self.mode.upcase} #{include_dirs}"
        puts command.cyan if verbose
        puts %x{ #{command} }
        
        if $?.exited? && ($?.exitstatus == 0)
            puts "#{'Linking Target'.yellow}: #{target.white.bold}"
            options = [ self.linker_options.join(' '), self.linker_mode_options.join(' ') ].join(' ')
            command = "#{self.linker} -o #{target} #{object_list.join(' ')} #{object} #{options}"
            puts command.cyan if verbose
            puts %x{ #{command} }
        end
        puts "#{'FAILED'.red} - Test #{test} failed to compile; see compilation output for details" unless File.exists? target

        if File.exists? target
            return target
        end
        nil
    end

    def run_test test, target, verbose
        if File.exists? target
            puts "Executing test suite #{target.white.bold} for #{test.yellow}" # if verbose
            puts %x{ #{target} }
            result = $?.exited? && ($?.exitstatus == 0)
            puts "#{((result) ? 'PASS'.green : 'FAIL'.red)} :: #{target.white.bold} -> #{test.white.bold}"
            return result
        end
        false
    end

    def assemble
        puts "Assembling #{self.mode.white.bold} target"
        verbose = @flags.verbose_flag
        FileUtils.mkdir_p "#{self.output}/exec"

        target = "#{self.output}/exec/#{self.target}"

        File.delete target if File.exists? target

        source_list, object_list = assemble_objects(verbose)

        if (object_list.length > 0) && (object_list.length == source_list.length)
            puts "#{'Linking Target'.yellow}: #{self.target.white.bold}"
            options = [ self.linker_options.join(' '), self.linker_mode_options.join(' ') ].join(' ')
            command = "#{self.linker} -o #{target} #{object_list.join(' ')} #{options}"
            puts command.cyan if verbose
            puts %x{ #{command} }
        end

        puts "#{'FAILED'.red} - See compilation output for details" unless File.exists? target
        true
    end

    def filter? name
        verbose = @flags.verbose_flag

        if name == '.' || name == '..' || File.directory?(name)
            return true
        end

        # Filter the files in the source directory
        if self.source_filters.length == 0
            puts "Reviewing: #{name}".cyan if verbose
            extension = File.extname name
            return true if [ '.h', '.o', '.swp', '.sh', '.bat', '.cmd', '.ps1' ].include? extension
            return true unless [ '.c', '.cc', '.cpp', '.cxx', '.c++' ].include? extension
        else
            match = false
            self.source_filters.each do |filter|
                puts "Reviewing: #{name} => #{filter} -> #{name} :: #{name.match? Regexp.new(filter)}".cyan if verbose
                match ||= name.match? Regexp.new(filter)
            end
            return true unless match
        end

        false
    end

    def build_commands commands, name
        if commands.length > 0
            commands.each do |command|
                puts "#{name.blue} #{command.white.bold}"
                puts %x{ #{command} }
                if !$?.exited? && ($?.exitstatus != 0)
                    puts "#{'ERROR'.red}: #{name} command #{command.white.bold} failed"
                    exit -1
                end
            end
        end
        puts ""
    end

end



flags = Flags.new(ARGV)

if flags.tasks_flag || flags.default_flag
    flags.print_tasks
end

builder = Builder.new(flags)

if flags.clean_flag
    builder.clean
end

if flags.test_flag
    builder.test
end

if flags.build_flag
    builder.build
end
